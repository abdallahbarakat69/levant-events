import { supabase } from '../supabaseClient';

// Helper to map DB snake_case to App camelCase
const mapClientFromDB = (dbClient) => ({
    ...dbClient,
    fullName: dbClient.full_name,
    salesmanId: dbClient.salesman_id,
    socialMedia: dbClient.social_media,
    updatedAt: dbClient.updated_at,
    // Remove snake_case keys if desired, or keep them. 
    // Spreading first then overwriting ensures we have both or just the ones we need.
});

// Helper to map App camelCase to DB snake_case
const mapClientToDB = (client) => ({
    full_name: client.fullName,
    phone: client.phone,
    email: client.email,
    notes: client.notes,
    salesman_id: client.salesmanId,
    social_media: client.socialMedia,
    website: client.website,
    // id is auto-generated by DB on insert usually, but if we pass it:
    ...(client.id && { id: client.id })
});

export const dataService = {
    // Clients
    getClients: async () => {
        const { data, error } = await supabase
            .from('clients')
            .select('*')
            .order('updated_at', { ascending: false });

        if (error) {
            console.error('Error fetching clients:', error);
            return [];
        }
        return data.map(mapClientFromDB);
    },

    addClient: async (client) => {
        const dbClient = mapClientToDB(client);
        // Remove ID to let DB generate it, or handle it if you want client-side UUIDs
        delete dbClient.id;

        const { data, error } = await supabase
            .from('clients')
            .insert([dbClient])
            .select()
            .single();

        if (error) throw error;
        return mapClientFromDB(data);
    },

    updateClient: async (id, updates) => {
        const dbUpdates = {};
        if (updates.fullName) dbUpdates.full_name = updates.fullName;
        if (updates.phone) dbUpdates.phone = updates.phone;
        if (updates.email) dbUpdates.email = updates.email;
        if (updates.notes) dbUpdates.notes = updates.notes;
        if (updates.salesmanId) dbUpdates.salesman_id = updates.salesmanId;
        if (updates.socialMedia) dbUpdates.social_media = updates.socialMedia;
        if (updates.website) dbUpdates.website = updates.website;

        const { data, error } = await supabase
            .from('clients')
            .update(dbUpdates)
            .eq('id', id)
            .select()
            .single();

        if (error) throw error;
        return mapClientFromDB(data);
    },

    deleteClient: async (id) => {
        const { error } = await supabase
            .from('clients')
            .delete()
            .eq('id', id);
        if (error) throw error;
    },

    // Salesmen
    getSalesmen: async () => {
        const { data, error } = await supabase
            .from('salesmen')
            .select('*')
            .order('name');

        if (error) {
            console.error('Error fetching salesmen:', error);
            return [];
        }
        return data; // Salesmen table uses simple names that match (name, email, phone, id)
    },

    addSalesman: async (salesman) => {
        // Salesman object keys (name, email, phone) match DB columns
        const { data, error } = await supabase
            .from('salesmen')
            .insert([salesman])
            .select()
            .single();

        if (error) throw error;
        return data;
    },

    deleteSalesman: async (id) => {
        const { error } = await supabase
            .from('salesmen')
            .delete()
            .eq('id', id);
        if (error) throw error;
    }
};
